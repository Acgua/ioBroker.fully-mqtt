{
  "version": 3,
  "sources": ["../../src/lib/methods.ts"],
  "sourcesContent": ["/**\r\n * Methods and Tools\r\n */\r\n\r\nimport { FullyMqtt } from '../main';\r\n\r\n/**\r\n * Convert error to string\r\n * @param {*} error - any kind of thrown error\r\n * @returns string\r\n */\r\nexport function err2Str(error: any): string {\r\n    if (error instanceof Error) {\r\n        if (error.stack) return error.stack;\r\n        if (error.message) return error.message;\r\n        return JSON.stringify(error);\r\n    } else {\r\n        if (typeof error === 'string') return error;\r\n        return JSON.stringify(error);\r\n    }\r\n}\r\n\r\n/**\r\n * Clean device name for state\r\n * @param str - device name\r\n * @returns device name without forbidden chars, and without any dots.\r\n */\r\nexport function cleanDeviceName(this: FullyMqtt, str: string): string {\r\n    let res = str.replace(this.FORBIDDEN_CHARS, ''); // https://github.com/ioBroker/ioBroker.js-controller/blob/master/packages/common/src/lib/common/tools.ts\r\n    res = res.replace(/\\./g, ''); // remove any dots \".\"\r\n    res = res.replace(/\\s{2,}/g, ' '); // replace multiple whitespaces with single space\r\n    res = res.trim(); // removes whitespace from both ends\r\n    res = res.replace(/\\s/g, '_'); // replace whitespaces with _\r\n    if (res.replace(/_/g, '').length === 0) res = ''; // return empty str if just _ is left\r\n    return res;\r\n}\r\n\r\n/**\r\n * Check if IP address is valid - https://stackoverflow.com/a/27434991\r\n * @param ip IP address\r\n * @returns true if valid, false if not\r\n */\r\nexport function isIpAddressValid(ip: string): true | false {\r\n    const pattern = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\r\n    if (pattern.test(ip)) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieve values from a CONFIG variable, example:\r\n * const CONF = [{car: 'bmw', color: 'black', hp: '250'}, {car: 'audi', color: 'blue', hp: '190'}]\r\n * To get the color of the Audi, use: getConfigValuePerKey(CONF, 'car', 'audi', 'color')\r\n * To find out which car has 190 hp, use: getConfigValuePerKey(CONF, 'hp', '190', 'car')\r\n * @param {object}  config     The configuration variable/constant\r\n * @param {string}  key1       Key to look for.\r\n * @param {string | number}  key1Value  The value the key should have\r\n * @param {string}  key2       The key which value we return\r\n * @returns {any}    Returns the element's value, or number -1 of nothing found.\r\n */\r\nexport function getConfigValuePerKey(config: { [k: string]: any }[], key1: string, key1Value: string | number, key2: string): any {\r\n    for (const lpConfDevice of config) {\r\n        if (lpConfDevice[key1] === key1Value) {\r\n            if (lpConfDevice[key2] === undefined) {\r\n                return -1;\r\n            } else {\r\n                return lpConfDevice[key2];\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\n/**\r\n * Checks if an operand (variable, constant, object, ...) is considered as empty.\r\n * - empty:     undefined; null; string|array|object, stringified and only with white space(s), and/or `><[]{}`\r\n * - NOT empty: not matching anything above; any function; boolean false; number -1\r\n * inspired by helper.js from SmartControl adapter\r\n */\r\nexport function isEmpty(toCheck: any): true | false {\r\n    if (toCheck === null || typeof toCheck === 'undefined') return true;\r\n    if (typeof toCheck === 'function') return false;\r\n    let x = JSON.stringify(toCheck);\r\n    x = x.replace(/\\s+/g, ''); // white space(s)\r\n    x = x.replace(/\"+/g, ''); // \"\r\n    x = x.replace(/'+/g, ''); // '\r\n    x = x.replace(/\\[+/g, ''); // [\r\n    x = x.replace(/\\]+/g, ''); // ]\r\n    x = x.replace(/\\{+/g, ''); // {\r\n    x = x.replace(/\\}+/g, ''); // }\r\n    return x === '' ? true : false;\r\n}\r\n\r\n/**\r\n * async wait/pause\r\n * Actually not needed since a single line, but for the sake of using wait more easily\r\n * @param {number} ms - number of milliseconds to wait\r\n */\r\nexport async function wait(this: FullyMqtt, ms: number): Promise<void> {\r\n    try {\r\n        await new Promise((w) => setTimeout(w, ms));\r\n    } catch (e) {\r\n        this.log.error(this.err2Str(e));\r\n        return;\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWO,SAAS,QAAQ,OAAoB;AACxC,MAAI,iBAAiB,OAAO;AACxB,QAAI,MAAM;AAAO,aAAO,MAAM;AAC9B,QAAI,MAAM;AAAS,aAAO,MAAM;AAChC,WAAO,KAAK,UAAU,KAAK;AAAA,EAC/B,OAAO;AACH,QAAI,OAAO,UAAU;AAAU,aAAO;AACtC,WAAO,KAAK,UAAU,KAAK;AAAA,EAC/B;AACJ;AAOO,SAAS,gBAAiC,KAAqB;AAClE,MAAI,MAAM,IAAI,QAAQ,KAAK,iBAAiB,EAAE;AAC9C,QAAM,IAAI,QAAQ,OAAO,EAAE;AAC3B,QAAM,IAAI,QAAQ,WAAW,GAAG;AAChC,QAAM,IAAI,KAAK;AACf,QAAM,IAAI,QAAQ,OAAO,GAAG;AAC5B,MAAI,IAAI,QAAQ,MAAM,EAAE,EAAE,WAAW;AAAG,UAAM;AAC9C,SAAO;AACX;AAOO,SAAS,iBAAiB,IAA0B;AACvD,QAAM,UAAU;AAChB,MAAI,QAAQ,KAAK,EAAE,GAAG;AAClB,WAAO;AAAA,EACX,OAAO;AACH,WAAO;AAAA,EACX;AACJ;AAaO,SAAS,qBAAqB,QAAgC,MAAc,WAA4B,MAAmB;AAC9H,aAAW,gBAAgB,QAAQ;AAC/B,QAAI,aAAa,UAAU,WAAW;AAClC,UAAI,aAAa,UAAU,QAAW;AAClC,eAAO;AAAA,MACX,OAAO;AACH,eAAO,aAAa;AAAA,MACxB;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AACX;AAQO,SAAS,QAAQ,SAA4B;AAChD,MAAI,YAAY,QAAQ,OAAO,YAAY;AAAa,WAAO;AAC/D,MAAI,OAAO,YAAY;AAAY,WAAO;AAC1C,MAAI,IAAI,KAAK,UAAU,OAAO;AAC9B,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,OAAO,EAAE;AACvB,MAAI,EAAE,QAAQ,OAAO,EAAE;AACvB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,MAAI,EAAE,QAAQ,QAAQ,EAAE;AACxB,SAAO,MAAM,KAAK,OAAO;AAC7B;AAOA,eAAsB,KAAsB,IAA2B;AACnE,MAAI;AACA,UAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,EAAE,CAAC;AAAA,EAC9C,SAAS,GAAP;AACE,SAAK,IAAI,MAAM,KAAK,QAAQ,CAAC,CAAC;AAC9B;AAAA,EACJ;AACJ;",
  "names": []
}
