{
  "version": 3,
  "sources": ["../../src/lib/mqtt-server.ts"],
  "sourcesContent": ["import Aedes from 'aedes';\r\nimport net from 'net';\r\nimport { FullyMqtt } from '../main';\r\nimport { IMqttDevice } from './interfaces';\r\n//import { inspect } from 'util';\r\n\r\nexport class MqttServer {\r\n    private readonly adapter: FullyMqtt;\r\n    private server: net.Server;\r\n    private aedes: Aedes;\r\n    public devices: { [mqttClientId: string]: IMqttDevice }; // {}\r\n    private port = -1;\r\n    private notAuthorizedClients: string[] = []; // to avoid multiple log lines\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    public constructor(adapter: FullyMqtt) {\r\n        this.adapter = adapter;\r\n        //this.server = new net.Server();\r\n        this.aedes = new Aedes();\r\n        /** @ts-expect-error - https://github.com/moscajs/aedes/issues/801 */\r\n        this.server = net.createServer(undefined, this.aedes.handle);\r\n        this.devices = {}; // key = MQTT Client ID, property: IMqttDevice\r\n    }\r\n\r\n    /**\r\n     * Listen\r\n     */\r\n    public start(): void {\r\n        try {\r\n            /**\r\n             * Port\r\n             */\r\n            this.port = this.adapter.config.mqttPort;\r\n            /**\r\n             * #############################################################\r\n             * For Developer only: change port if in dev environment\r\n             * #############################################################\r\n             */\r\n            if (this.adapter.adapterDir.includes('/.dev-server/default/node_modules')) {\r\n                this.port = 3012;\r\n                this.adapter.log.warn(`DEVELOPER: Port changed to ${this.port} as we are in DEV Environment! If you see this log message, please open an issue on Github.`);\r\n            }\r\n\r\n            /**\r\n             * Start Listening\r\n             */\r\n            this.server.listen(this.port, () => {\r\n                this.adapter.log.info(`\uD83D\uDE80 MQTT Server started and is listening on port ${this.port}.`);\r\n            });\r\n\r\n            /**\r\n             * Verify authorization\r\n             * This fires first and before this.aedes.on('client', (client) ...\r\n             * https://github.com/moscajs/aedes/blob/main/docs/Aedes.md#handler-authenticate-client-username-password-callback\r\n             */\r\n            this.aedes.authenticate = (client, username, password, callback) => {\r\n                try {\r\n                    // If we saw client before and is not authorized\r\n                    if (this.notAuthorizedClients.includes(client.id)) {\r\n                        callback(null, false);\r\n                        return;\r\n                    }\r\n\r\n                    // Create device entry with id as key, if not yet existing\r\n                    if (!this.devices[client.id]) this.devices[client.id] = {};\r\n\r\n                    /**\r\n                     * Get IP\r\n                     * This rather complicated way is needed, see https://github.com/moscajs/aedes/issues/186\r\n                     * Not sure if this always works, but client.req was undefined in my test - which is suggested in https://github.com/moscajs/aedes/issues/527\r\n                     */\r\n                    let ip: string | undefined = undefined;\r\n                    if (client.conn && 'remoteAddress' in client.conn && typeof client.conn.remoteAddress === 'string') {\r\n                        const ipSource = client.conn.remoteAddress; // like: ::ffff:192.168.10.101\r\n                        this.adapter.log.debug(`[MQTT] client.conn.remoteAddress = \"${ipSource}\" - ${client.id}`);\r\n                        ip = ipSource.substring(ipSource.lastIndexOf(':') + 1); // get everything after last \":\"\r\n                        if (!this.adapter.isIpAddressValid(ip)) ip === undefined;\r\n                    }\r\n                    // Check if IP is an active device IP\r\n                    if (ip && !Object.keys(this.adapter.fullysEnbl).includes(ip)) {\r\n                        this.adapter.log.error(`[MQTT] Client ${client.id} not authorized: ${ip} is not an active Fully device IP per adapter settings.`);\r\n                        this.notAuthorizedClients.push(client.id);\r\n                        callback(null, false);\r\n                        return;\r\n                    }\r\n\r\n                    const ipMsg = ip ? `${this.adapter.fullysEnbl[ip].name} (${ip})` : `${client.id} (IP unknown)`;\r\n                    this.adapter.log.debug(`[MQTT] Client ${ipMsg} trys to authenticate...`);\r\n                    if (ip) this.devices[client.id].ip = ip;\r\n\r\n                    /**\r\n                     * Verify User and Password\r\n                     */\r\n                    if (!this.adapter.config.mqttDoNotVerifyUserPw) {\r\n                        // Username\r\n                        if (username !== this.adapter.config.mqttUser) {\r\n                            this.adapter.log.warn(`MQTT Client ${ipMsg} Authorization rejected: received user name '${username}' does not match '${this.adapter.config.mqttUser}' in adapter settings.`);\r\n                            callback(null, false);\r\n                            return;\r\n                        }\r\n                        // Password\r\n                        if (password.toString() !== this.adapter.config.mqttPassword) {\r\n                            this.adapter.log.warn(`MQTT Client ${ipMsg} Authorization rejected: received password does not match with password in adapter settings.`);\r\n                            callback(null, false);\r\n                            return;\r\n                        }\r\n                    }\r\n                    this.adapter.log.info(`\uD83D\uDD11 MQTT Client ${ipMsg} successfully authenticated.`);\r\n                    callback(null, true);\r\n                } catch (e) {\r\n                    this.adapter.log.error(this.adapter.err2Str(e));\r\n                    callback(null, false);\r\n                }\r\n            };\r\n\r\n            /**\r\n             * fired when a client connects\r\n             */\r\n            this.aedes.on('client', (client) => {\r\n                try {\r\n                    if (!client) return;\r\n\r\n                    // Create device entry with id as key, if not yet existing (should have been set in this.aedes.authenticate already)\r\n                    if (!this.devices[client.id]) this.devices[client.id] = {};\r\n\r\n                    // IP\r\n                    const ip = this.devices[client.id].ip;\r\n                    const ipMsg = ip ? `${this.adapter.fullysEnbl[ip].name} (${ip})` : `${client.id} (IP unknown)`;\r\n\r\n                    this.adapter.log.debug(`[MQTT] Client ${ipMsg} connected to broker ${this.aedes.id}`);\r\n                    this.adapter.log.info(`\uD83D\uDD17 MQTT Client ${ipMsg} successfully connected.`);\r\n                    //this.adapter.log.debug(inspect(client)); //https://stackoverflow.com/a/31557814\r\n\r\n                    // set isAlive\r\n                    this.setIsAlive(client.id, true, 'client connected');\r\n\r\n                    // Schedule check if still alive\r\n                    this.scheduleCheckIfStillActive(client.id);\r\n                } catch (e) {\r\n                    this.adapter.log.error(this.adapter.err2Str(e));\r\n                    return;\r\n                }\r\n            });\r\n\r\n            /**\r\n             * fired when a client publishes a message packet on the topic\r\n             */\r\n            this.aedes.on('publish', (packet, client) => {\r\n                try {\r\n                    if (!client || !packet) return;\r\n\r\n                    this.setIsAlive(client.id, true, 'client published message');\r\n\r\n                    // Create device entry with id as key, if not yet existing\r\n                    if (!this.devices[client.id]) this.devices[client.id] = {};\r\n\r\n                    // QOS is always 1 per Fully documentation\r\n                    if (packet.qos !== 1) return;\r\n\r\n                    if (packet.retain) {\r\n                        /**\r\n                         * Device Info coming in...\r\n                         * Per fully documentation: The complete device info will be published every 60 seconds as fully/deviceInfo/[deviceId] topic (retaining, QOS=1).\r\n                         */\r\n\r\n                        // Payload as object\r\n                        const info = JSON.parse(packet.payload.toString());\r\n\r\n                        // Verification of device info packet\r\n                        // We don't use topic to check since we do not want to rely on user's input in Fully Browser \"MQTT Device Info Topic\" settings.\r\n                        if (!('startUrl' in info) && !('ip4' in info)) {\r\n                            this.adapter.log.error(`[MQTT] Packet rejected: ${info.ip4} - Info packet expected, but ip4 and startUrl is not defined in packet. ${info.deviceId}`);\r\n                            return;\r\n                        }\r\n\r\n                        // IP\r\n                        const ip = info.ip4;\r\n                        const devMsg = `${this.adapter.fullysEnbl[ip].name} (${ip})`;\r\n                        // Check IP - already done in this.aedes.authenticate, but just in case we were unable to get ip there\r\n                        if (!Object.keys(this.adapter.fullysEnbl).includes(ip)) {\r\n                            this.adapter.log.error(`[MQTT] Client ${devMsg} Packet rejected: IP is not allowed per adapter settings. ${client.id}`);\r\n                            return;\r\n                        }\r\n                        this.devices[client.id].ip = ip;\r\n\r\n                        // Slow down: Don't accept info event more often than x seconds\r\n                        // Per Fully doc, should not come in more often than 60s anyway...\r\n                        const prevTime = this.devices[client.id].previousInfoPublishTime;\r\n                        const limit = this.adapter.config.mqttPublishedInfoDelay * 1000; // milliseconds\r\n                        if (prevTime && prevTime !== 0) {\r\n                            if (Date.now() - prevTime < limit) {\r\n                                const diffMs = Date.now() - prevTime;\r\n                                this.adapter.log.silly(`[MQTT] ${devMsg} Packet rejected: Last packet came in ${diffMs}ms (${Math.round(diffMs / 1000)}s) ago...`);\r\n                                return;\r\n                            }\r\n                        }\r\n                        this.devices[client.id].previousInfoPublishTime = Date.now(); // set for future events\r\n\r\n                        /**\r\n                         * First time received device info incl. IP address etc.\r\n                         */\r\n                        if (!this.devices[client.id].mqttFirstReceived) {\r\n                            // show only once\r\n                            this.adapter.log.debug(`[MQTT] Client ${client.id} = ${this.adapter.fullysEnbl[ip].name} = ${ip}`);\r\n                            // set to true\r\n                            this.devices[client.id].mqttFirstReceived = true;\r\n                        }\r\n                        /**\r\n                         * Call Adapter function onMqttInfo()\r\n                         */\r\n                        const result = {\r\n                            clientId: client.id,\r\n                            ip: ip,\r\n                            topic: packet.topic,\r\n                            infoObj: info,\r\n                        };\r\n                        this.adapter.onMqttInfo(result);\r\n                    } else if (packet.qos === 1 && !packet.retain) {\r\n                        /**\r\n                         * Event coming in...\r\n                         * Per fully documentation: Events will be published as fully/event/[eventId]/[deviceId] topic (non-retaining, QOS=1).\r\n                         */\r\n                        // {\"deviceId\":\"xxxxxxxx-xxxxxxxx\",\"event\":\"screenOn\"}\r\n                        // NOTE: Device ID is different to client id, we actually disregard deviceId\r\n                        const msg = JSON.parse(packet.payload.toString());\r\n\r\n                        // Verification of event packet\r\n                        // We don't use topic to check since we do not want to rely on user's input in Fully Browser \"MQTT Event Topic\" settings.\r\n                        if (!('event' in msg)) {\r\n                            this.adapter.log.error(`[MQTT] Packet rejected: Event packet expected, but event is not defined in packet. ${client.id}`);\r\n                            return;\r\n                        }\r\n\r\n                        // Disregard first event once connected: mqttConnected\r\n                        if (msg.event === 'mqttConnected') {\r\n                            this.adapter.log.silly(`[MQTT] Client Publish Event: Disregard mqttConnected event - ${msg.deviceId}`);\r\n                            return;\r\n                        }\r\n\r\n                        // Get IP\r\n                        if (!this.devices[client.id]) {\r\n                            this.adapter.log.info(`[MQTT] Client Publish Event: Device ID and according IP not yet seen thru \"Publish Info\"`);\r\n                            this.adapter.log.info(`[MQTT] We wait until first info is published. ${msg.deviceId}`);\r\n                            return;\r\n                        }\r\n                        const ip = this.devices[client.id].ip ? this.devices[client.id].ip : '';\r\n                        if (ip === '' || typeof ip !== 'string') {\r\n                            this.adapter.log.debug(`[MQTT] Client Publish Event: IP address could not be determined. - Client ID: ${client.id}`);\r\n                            this.adapter.log.debug(`[MQTT] Please be patient until first MQTT info packet coming in (takes up to 1 minute)`);\r\n                            return; // Disregard since IP is unknown!\r\n                        }\r\n\r\n                        // Call function\r\n                        const result = {\r\n                            clientId: client.id,\r\n                            ip: ip,\r\n                            topic: packet.topic,\r\n                            cmd: msg.event,\r\n                        };\r\n                        if (!this.devices[client.id].mqttFirstReceived) {\r\n                            // show only once\r\n                            this.adapter.log.info(`[MQTT] \uD83D\uDD17 Client ${client.id} = ${this.adapter.fullysEnbl[ip].name} (${ip})`);\r\n                            this.devices[client.id].mqttFirstReceived = true;\r\n                        }\r\n                        /**\r\n                         * Call Adapter function onMqttEvent()\r\n                         */\r\n                        this.adapter.onMqttEvent(result);\r\n                    } else {\r\n                        // Ignore\r\n                        return;\r\n                    }\r\n                } catch (e) {\r\n                    this.adapter.log.error(this.adapter.err2Str(e));\r\n                    return;\r\n                }\r\n            });\r\n\r\n            /**\r\n             * fired when a client disconnects\r\n             */\r\n            this.aedes.on('clientDisconnect', (client) => {\r\n                const ip = this.devices[client.id].ip;\r\n                const logMsgName = ip ? this.adapter.fullysEnbl[ip].name : client.id;\r\n                if (this.adapter.config.mqttConnErrorsAsInfo) {\r\n                    this.adapter.log.info(`MQTT Client ${logMsgName} disconnected.`);\r\n                } else {\r\n                    this.adapter.log.error(`[MQTT] Client ${logMsgName} disconnected.`);\r\n                }\r\n                this.setIsAlive(client.id, false, 'client disconnected');\r\n            });\r\n\r\n            /**\r\n             * fired on client error\r\n             */\r\n            this.aedes.on('clientError', (client, e) => {\r\n                if (this.notAuthorizedClients.includes(client.id)) return; // Error msg was already thrown in aedes.authenticate() before\r\n                const ip = this.devices[client.id].ip;\r\n                const logMsgName = ip ? this.adapter.fullysEnbl[ip].name : client.id;\r\n                if (this.adapter.config.mqttConnErrorsAsInfo) {\r\n                    this.adapter.log.info(`[MQTT] ${logMsgName}: Client error - ${e.message}`);\r\n                } else {\r\n                    this.adapter.log.error(`[MQTT]\uD83D\uDD25 ${logMsgName}: Client error - ${e.message}`);\r\n                }\r\n                this.adapter.log.debug(`[MQTT]\uD83D\uDD25 ${logMsgName}: Client error - stack: ${e.stack}`);\r\n                this.setIsAlive(client.id, false, 'client error');\r\n            });\r\n\r\n            this.aedes.on('connectionError', (client, e) => {\r\n                const ip = this.devices[client.id].ip;\r\n                const logMsgName = ip ? this.adapter.fullysEnbl[ip].name : client.id;\r\n                if (this.adapter.config.mqttConnErrorsAsInfo) {\r\n                    this.adapter.log.info(`[MQTT] ${logMsgName}: Connection error - ${e.message}`);\r\n                } else {\r\n                    this.adapter.log.error(`[MQTT]\uD83D\uDD25 ${logMsgName}: Connection error - ${e.message}`);\r\n                }\r\n                this.adapter.log.debug(`[MQTT]\uD83D\uDD25 ${logMsgName}: Connection error - stack: ${e.stack}`);\r\n                this.setIsAlive(client.id, false, 'connection error');\r\n            });\r\n\r\n            /**\r\n             * fired on server error\r\n             */\r\n            this.server.on('error', (e: any) => {\r\n                if (e instanceof Error && e.message.startsWith('listen EADDRINUSE')) {\r\n                    this.adapter.log.debug(`[MQTT] Cannot start server - ${e.message}`);\r\n                    this.adapter.log.error(`[MQTT]\uD83D\uDD25 Cannot start server - Port ${this.port} is already in use. Try a different port!`);\r\n                } else {\r\n                    this.adapter.log.error(`[MQTT]\uD83D\uDD25 Cannot start server - ${e.message}`);\r\n                }\r\n                this.terminate();\r\n            });\r\n        } catch (e) {\r\n            this.adapter.log.error(this.adapter.err2Str(e));\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If Client is alive or not\r\n     */\r\n    private setIsAlive(clientId: string, isAlive: true | false, msg: string): void {\r\n        if (isAlive) this.devices[clientId].lastTimeActive = Date.now();\r\n        this.devices[clientId].isActive = isAlive;\r\n\r\n        const ip = this.devices[clientId]?.ip;\r\n        if (ip) {\r\n            // Call Adapter function onMqttAliveChange()\r\n            this.adapter.onMqttAlive(ip, isAlive, msg);\r\n            if (isAlive) {\r\n                this.scheduleCheckIfStillActive(clientId); // restart timer\r\n            } else {\r\n                // clear timer\r\n                // @ts-expect-error \"Type 'null' is not assignable to type 'Timeout'.ts(2345)\" - we check for not being null via \"if\"\r\n                if (this.devices[clientId].timeoutNoUpdate) this.adapter.clearTimeout(this.devices[clientId].timeoutNoUpdate);\r\n            }\r\n        } else {\r\n            this.adapter.log.debug(`[MQTT] isAlive changed to ${isAlive}, but IP of client ${clientId} is still unknown.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Schedule: Check if MQTT topic was sent last x seconds ago\r\n     * @param ip IP Address\r\n     * @returns void\r\n     */\r\n    private async scheduleCheckIfStillActive(clientId: string): Promise<void> {\r\n        try {\r\n            const ip = this.devices[clientId].ip;\r\n            const ipMsg = ip ? `${this.adapter.fullysEnbl[ip].name} (${ip})` : `${clientId} (IP unknown)`;\r\n            // this.adapter.log.debug(`[MQTT] ${ipMsg}: - Start scheduleCheckIfStillActive`);\r\n\r\n            // @ts-expect-error \"Type 'null' is not assignable to type 'Timeout'.ts(2345)\" - we check for not being null via \"if\"\r\n            if (this.devices[clientId].timeoutNoUpdate) this.adapter.clearTimeout(this.devices[clientId].timeoutNoUpdate);\r\n\r\n            if (!this.devices[clientId]) this.devices[clientId] = {};\r\n\r\n            const interval = 70 * 1000; // every 60s + 10s buffer\r\n            this.devices[clientId].timeoutNoUpdate = this.adapter.setTimeout(async () => {\r\n                try {\r\n                    const lastTimeActive = this.devices[clientId].lastTimeActive;\r\n                    if (!lastTimeActive) return;\r\n                    const diff = Date.now() - lastTimeActive;\r\n                    if (diff > 70000) {\r\n                        this.adapter.log.debug(`[MQTT] ${ipMsg} NOT ALIVE - last contact ${Math.round(diff / 1000)}s (${diff}ms) ago`);\r\n                        this.setIsAlive(clientId, false, 'client did not send message for more than 70 seconds');\r\n                    } else {\r\n                        this.adapter.log.warn(`[MQTT] ${ipMsg} Please open a issue on Github, this should never happen: scheduleCheckIfStillActive() timeout, and last contact was less than 70s ago.`);\r\n                        this.adapter.log.warn(`[MQTT] ${ipMsg} is alive - last contact ${Math.round(diff / 1000)}s (${diff}ms) ago`);\r\n                        this.setIsAlive(clientId, true, `alive check is successful (last contact: ${Math.round(diff / 1000)}s ago)`);\r\n                    }\r\n                    // Call function again since we are in callback of timeout\r\n                    this.scheduleCheckIfStillActive(clientId);\r\n                } catch (e) {\r\n                    this.adapter.log.error(this.adapter.err2Str(e));\r\n                    return;\r\n                }\r\n            }, interval);\r\n        } catch (e) {\r\n            this.adapter.log.error(this.adapter.err2Str(e));\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Terminate MQTT Server and close all...\r\n     */\r\n    public terminate(): void {\r\n        this.adapter.log.info(`[MQTT] Disconnect all clients and close server`);\r\n        // isAlive\r\n        for (const clientId in this.devices) {\r\n            // @ts-expect-error \"Type 'null' is not assignable to type 'Timeout'.ts(2345)\" - we check for not being null via \"if\"\r\n            if (this.devices[clientId].timeoutNoUpdate) this.adapter.clearTimeout(this.devices[clientId].timeoutNoUpdate);\r\n            this.setIsAlive(clientId, false, 'MQTT server was terminated');\r\n        }\r\n\r\n        if (this.aedes) {\r\n            this.aedes.close(() => {\r\n                this.adapter.log.debug('[MQTT] aedes.close() succeeded');\r\n                if (this.server) {\r\n                    this.server.close(() => {\r\n                        this.adapter.log.debug('[MQTT] server.close() succeeded');\r\n                    });\r\n                }\r\n            });\r\n        } else if (this.server) {\r\n            this.server.close(() => {\r\n                this.adapter.log.debug('[MQTT] server.close() succeeded');\r\n            });\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["Aedes", "net"]
}
